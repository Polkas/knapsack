---
title: "Amino_KasaRomana"
author: "Maciej Nasinski"
date: "6 paŸdziernika 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Poni¿sza analiza zosta³a przeprowadzona w celach edukacyjnych przy najwy¿szej starannoœci. Wykorzystuj¹c baze danych zawieraj¹c¹ wartoœci 1002 kuponów zbadano ich charakterystyki oraz szanse na wygran¹. W procesie znajdowania par kuponów potzrebnych do wygrania wyko¿ystano algorytm knapsack. Wszystkie obliczenia zosta³y wykonane w programie R.

[Regulamin Promocji](http://www.kasaromana.pl/Regulamin-Kasa-Romana.pdf)

¯ród³o bazy danych:

[Warotœci z 1000 zupek otwartych na kanale Youtube "Bez Kana³u"](https://www.facebook.com/BezKanalu/)

Wgranie wszystkich obserwacji.

```{r}
kupony = as.numeric(readLines("./knapsack.txt"))

kupony
```

Wykres rosn¹cych wartoœci unikalnych:

Z wszystkich wartoœci wyrzucono te powtarzaj¹ce siê a nastêpnie posortowano do najmniejszej do najwiekszej.

```{r}
plot(sort(unique(kupony)))
```

£atwo zaobserwowaæ ¿e wystêpuje pewna zale¿noœæ.

Histrogram:

```{r}
hist(kupony,breaks=100)
```

Histogram ukazuje ¿e pewne wartoœci powtarzaj¹ siê du¿o czêœciej ni¿ inne.

Liczby wydaj¹ siê byæ generowane z dwóch scie¿ek:

- jako kolejne iloczyny liczby 13 zaczynaj¹c od 26
- liczba 165 oraz sumowanie jej z kolejnymi iloczynami liczby 13

```{r}
rep13 = sapply(1:52,function(x) 13*x)

rep2_13 = sapply(1:45,function(x) 165+(13*x))

sum(kupony %in% rep13 & kupony %in% rep2_13)
```

Wszystkie kupony z naszej bazy danych znajduj¹ siê poœród wszystkich wygenerownych liczb z 2 podanych œcie¿ek.

Porównanie kuponów z bazy danych oraz wygnerowanych. 

Do kuponów z bazy danych dodano kupon o kwocie 178.

```{r}
a = sort(c(unique(kupony),178))
b = sort(c(sapply(0:45,function(x) 165+(13*x)),sapply(2:50,function(x) (13*x))))

both = data.frame(realne = a, wygenerowane = b)

both
```

*Single knapsack problem:*

Knapsack to metoda optymalizacyjna, linear programming dla liczb ca³kowitych.

WYkorzystuj¹c po 100 wartoœci z ka¿dego unikalnego kuponu przerowadzono wnioskowanie. Nalezy zanzaczyæ i¿ wykorzystuj¹c po jednej wartoœci ka¿dego kuponu wyniki sa identyczne. Dla przypomnienia poszukujemy takiej kombiacji kuponów, która bêdzie siê sumowaæ do kolejnych iloczynów setki a¿ do tysi¹ca.

```{r}
library(adagio)

cupon_we_have = rep(both$wygenerowane,100)

cupon_we_want = seq(100,1000,100)

for(i in cupon_we_want){

solution <- try(knapsack(p=cupon_we_have[cupon_we_have<i], w=cupon_we_have[cupon_we_have<i], cap=i))

print(solution$profit)
}

```

Wykorzystuj¹c kupony z bazy danych nie jest mozliwe osi¹gniêcie jakiegokolwiek zysku.

*Dodatek ukazuj¹cy co gdyby na kuponach by³y liczby z rozk³adu ci¹g³ego (zaokr¹glone do ca³kowitych):*

Symulacja z kuponami z rozk³adu ci¹g³ego z zaokraglonymi wartoœciami. Postaramy siê odnaleŸæ jak najwiêcej 1000 ¿³otych.

```{r}
set.seed(1234)

cupon_we_have = round(c(runif(1000,26,750)))

hist(cupon_we_have,10)

cupon_we_want=c(1000)

prof = 0

repeat{

solution <- try(mknapsack(p=cupon_we_have, w=cupon_we_have, k=cupon_we_want,bck=0))

if(class(solution)=="try-error") break

diff = NULL

for(i in 1:length(cupon_we_want)) diff[i] = cupon_we_want[i] - sum(cupon_we_have[solution$ksack==i])

if(all(diff==0)) cupon_we_want = c(cupon_we_want,1000) else break

prof = prof + 1
}

c = cupon_we_have
names(c) = solution$ksack
c = c[sort(as.numeric(names(c)),index.return=TRUE)$ix]
c = c[!names(c)==0]
c
```

Wygrana przy tym konkretnym losowaniu mog³aby osi¹gn¹æ `r (prof-1)` tysiêcy z³otych. Dla innych losowañ wartoœci kuponów z zaprezentowanego rozk³adu, wygrane s¹ bardzo zbli¿one. Dlatego z oczywistych wzglêdów w konkursie Amino zaimplementowano szczególny algorytm generowania liczb losowych. Jednak pytaniem pozostaje jak czesto i czy wogole wystêpuj¹ kupony pozwalaj¹ce na wygran¹.
